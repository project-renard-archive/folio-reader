#!/usr/bin/env perl

BEGIN {#{{{
	local $ENV{PERL_DL_NONLAZY} = 1;
	#$ENV{PERL_TKX_TRACE} = 64;
	require Tkx;
	Tkx::package_require("Img");
	
	Tkx::package_require("Tcl");
	Tkx::package_require("autoscroll");

	Tkx::package_require("Tcldot");
	
	local $ENV{PERL_DL_NONLAZY} = 0;
	$|=1; # TODO
}#}}}
# Packages {{{
use strict;
use FindBin qw($Bin);
use lib "$Bin/../lib";
#use Memoize;
#memoize('_memo_help');
use List::Util;
use File::Temp qw/ tempfile /;
use File::Basename;
use File::Slurp qw/write_file/;
use PDL;
#use PDL::NiceSlice;

use Carp;

use Folio::Viewer::PageManager::PDF;
use Folio::Viewer::Tkx::TextANSI;
use Folio::Viewer::Tkx::Imager;
use Folio::Viewer::Tkx::Timer;

use threads;
use threads::shared;

use Fetch::Paper;
use Fetch::Paper::Proxy;
#}}}
# Variables {{{
my $file; # filename
my $doc; # MuPDF::Easy::Doc
my $doc_bounds; # PDL

my $manage = Folio::Viewer::PageManager::PDF->new;
my $fetcher = Fetch::Paper->new();
my $proxy = Fetch::Paper::Proxy->new( fetch => $fetcher );

my $results; # arrayref of results
my $current_doc; # current selected document to load from $results

my $thread;
my $thread_run :shared; $thread_run = 1;
my $thread_done :shared; $thread_done = 0;
my $request_num = 0;
my $response_num = 0;
my @request_todo :shared;
my %request_doc :shared;
my @response_done :shared;
my $request_cleanup_repeat = 1;
#my $response_cleanup_repeat = 1;
my $progress_var :shared;

my %mainWindow; # widgets
#}}}
# Create windows {{{
sub addMainWindow {#{{{
    $mainWindow{mw} = Tkx::widget->new('.');
    ($mainWindow{main_page_image} = $mainWindow{mw}->new_ttk__label())->g_pack;
}#}}}
sub  addRetrievalWindow {#{{{
	addMainWindow unless $mainWindow{mw};
	$mainWindow{retrieval} = $mainWindow{mw}->new_toplevel;

	$mainWindow{retrieval}->g_wm_title("Search");


	($mainWindow{retrieval_paned} = $mainWindow{retrieval}->new_ttk__panedwindow(-orient => 'vertical'))
		->g_pack(-expand => 1, -fill => 'both');
	# Search frame {{{
	$mainWindow{retrieval_search} = $mainWindow{retrieval}->new_ttk__frame();

	($mainWindow{retrieval_search_label} = $mainWindow{retrieval_search}->new_ttk__label())->g_pack(-side => 'left');
		$mainWindow{retrieval_search_label}->configure( -text => "Search");
	($mainWindow{retrieval_search_entry} = $mainWindow{retrieval_search}
		->new_tk__text(-height => 1, -wrap => 'word'));
	($mainWindow{retrieval_search_entry_yscroll} = $mainWindow{retrieval_search}
		->new_ttk__scrollbar(-orient => 'vertical',
			-command => [$mainWindow{retrieval_search_entry}, 'yview']));
	$mainWindow{retrieval_search_entry_yscroll}->g_pack(-side => 'right', -fill => 'y');
	$mainWindow{retrieval_search_entry}->g_pack(-side => 'right', -fill => 'both', -expand => 1);
	$mainWindow{retrieval_search_entry}
		->configure(-yscrollcommand => [$mainWindow{retrieval_search_entry_yscroll}, 'set']);
	$mainWindow{retrieval_search_entry_yscroll}->g___autoscroll__autoscroll;
	# }}}
	# Results frame {{{
	$mainWindow{retrieval_resultsframe} = $mainWindow{retrieval}
		->new_ttk__frame(-borderwidth => 2, -relief => "sunken", -width => 100, -height => 100);

	# Listbox {{{
	$mainWindow{retrieval_resultsframe_list} = $mainWindow{retrieval_resultsframe}
		->new_tk__listbox();
	$mainWindow{retrieval_resultsframe_yscroll} = $mainWindow{retrieval_resultsframe}
		->new_ttk__scrollbar(-orient => 'vertical',
			-command => [$mainWindow{retrieval_resultsframe_list}, 'yview']);
	$mainWindow{retrieval_resultsframe_list}
		->configure(-yscrollcommand => [$mainWindow{retrieval_resultsframe_yscroll}, 'set']);
	$mainWindow{retrieval_resultsframe_list}->g_pack(-side => 'left', -fill => 'both', -expand => 1);
	$mainWindow{retrieval_resultsframe_yscroll}->g_pack(-side => 'right', -fill => 'y');
	$mainWindow{retrieval_resultsframe_yscroll}->g___autoscroll__autoscroll;

	# }}}
	# }}}
	# Results info frame {{{
	$mainWindow{retrieval_resultsinfo} = $mainWindow{retrieval}
		->new_ttk__frame(-borderwidth => 2, -relief => "sunken", -width => 100, -height => 100);
	$mainWindow{retrieval_resultsinfo_text} = $mainWindow{retrieval_resultsinfo}
		->new_tk__text(-height => 10, -wrap => 'word');
	$mainWindow{retrieval_resultsinfo_yscroll} = $mainWindow{retrieval_resultsinfo}
		->new_ttk__scrollbar(-orient => 'vertical',
			-command => [$mainWindow{retrieval_resultsinfo_text}, 'yview']);
	$mainWindow{retrieval_resultsinfo_yscroll}->g_pack(-side => 'right', -fill => 'y');
	$mainWindow{retrieval_resultsinfo_text}->g_pack(-side => 'right', -fill => 'both', -expand => 1);
	$mainWindow{retrieval_resultsinfo_text}
		->configure(-yscrollcommand => [$mainWindow{retrieval_resultsinfo_yscroll}, 'set']);
	$mainWindow{retrieval_resultsinfo_yscroll}->g___autoscroll__autoscroll;
	# }}}
	# Paned window  {{{
	$mainWindow{retrieval_paned}->add($mainWindow{retrieval_search});
	$mainWindow{retrieval_paned}->add($mainWindow{retrieval_resultsframe});
	$mainWindow{retrieval_paned}->add($mainWindow{retrieval_resultsinfo});
	# }}}
	# [old] Grid layout {{{

	#$mainWindow{retrieval_search}->g_grid(-column => 0, -row => 0, -sticky => "nesw");
	#$mainWindow{retrieval_resultsframe}
		#->g_grid(-column => 0, -row => 1, -columnspan => 2, -sticky => "nesw");
	#$mainWindow{retrieval_resultsinfo}
		#->g_grid(-column => 0, -row => 2, -columnspan => 2, -sticky => "nesw");
	#$mainWindow{retrieval}->g_grid_columnconfigure(0, -weight => 1);
	#$mainWindow{retrieval}->g_grid_rowconfigure(1, -weight => 1);
	#$mainWindow{retrieval}->g_grid_rowconfigure(2, -weight => 1);

	#}}}

	#$mainWindow{retrieval}->g_wm_geometry("300x400")
}#}}}
sub addCanvasWindow {#{{{
	$mainWindow{cw} = $mainWindow{mw}->new_toplevel;
	$mainWindow{cw_cv} = $mainWindow{cw}->new_tk__canvas();
	($mainWindow{cw_cv_y} = $mainWindow{cw}->new_ttk__scrollbar(-orient => 'vertical',
			-command => [$mainWindow{cw_cv}, 'yview']));
	($mainWindow{cw_cv_x} = $mainWindow{cw}->new_ttk__scrollbar(-orient => 'horizontal',
			-command => [$mainWindow{cw_cv}, 'xview']));

	$mainWindow{cw_cv}->g_grid(-column=>0, -row=>0, -sticky=>"nwes");
	$mainWindow{cw}->g_grid_columnconfigure(0, -weight => 1);
	$mainWindow{cw}->g_grid_rowconfigure(0, -weight => 1);
	$mainWindow{cw_cv_x}->g_grid(-column => 0, -row => 1, -sticky => "we");
	$mainWindow{cw_cv_y}->g_grid(-column => 1, -row => 0, -sticky => "ns");
	$mainWindow{cw}->new_ttk__sizegrip()->g_grid(-column => 1, -row => 1, -sticky => "se");


	# Visible canvas <http://wiki.tcl.tk/1415>
	# [[Kinetic scrolling|http://wiki.tcl.tk/28780]]
	# & Panning
	my $scroll_control = sub {
		my $dir = pop;
		if($dir eq "v" ) {
			$mainWindow{cw_cv_y}->set(@_);
		} elsif($dir eq "h") {
			$mainWindow{cw_cv_x}->set(@_);
		}
		my $canvas = $mainWindow{cw_cv};
		my $pages_visible = canvas_visible_tags($canvas);
		my $max_page_no = -1;
		for my $page (@$pages_visible) {
			$page =~ /page_no_(\d+)/;
			my $page_no = $1;
			$max_page_no = List::Util::max($max_page_no, $page_no);
			draw_page_tag($page);
		}
		draw_page_tag("page_no_@{[$max_page_no+1]}");
	};

	$mainWindow{cw_cv}->configure(-yscrollcommand => [$scroll_control, 'v']);
	$mainWindow{cw_cv}->configure(-xscrollcommand => [$scroll_control, 'h']);
	$mainWindow{cw_cv_y}->g___autoscroll__autoscroll;
	$mainWindow{cw_cv_x}->g___autoscroll__autoscroll;
}#}}}

# From <http://wiki.tcl.tk/1415>
## Tcl code {{{
###  MAK - Finding Visible or Partly Visible Items
###
###  This function will return all of the tags for items that are currently visible (either entirely visible if partial is 0 or partly off-screen if partial is 1) within the canvas, provided you've got your scroll region set correctly.
###
###   proc canvasVisibleTags { hWnd {partial 1} } {
###      foreach { xmin ymin xmax ymax } [$hWnd cget -scrollregion] break
###      foreach { y1 y2 } [$hWnd yview] break
###      foreach { x1 x2 } [$hWnd xview] break
###
###      set top   [expr {($ymax - $ymin) * $y1 + $ymin}]
###      set bot   [expr {($ymax - $ymin) * $y2 + $ymin}]
###      set left  [expr {($xmax - $xmin) * $x1 + $xmin}]
###      set right [expr {($xmax - $xmin) * $x2 + $xmin}]
###
###      if {$partial} {
###          return [$hWnd find overlapping $left $top $right $bot]
###      } else {
###          return [$hWnd find enclosed $left $top $right $bot]
###      }
###   }
## }}}
sub canvas_visible_tags {#{{{
	my ($canvas, $partial) = @_;
	$partial //= 1;
	my ($xmin, $ymin, $xmax, $ymax) =  Tkx::SplitList($canvas->cget('-scrollregion'));
	my ($y1, $y2) = Tkx::SplitList($canvas->yview);
	my ($x1, $x2) = Tkx::SplitList($canvas->xview);

	my $top   = ($ymax - $ymin) * $y1 + $ymin;
	my $bot   = ($ymax - $ymin) * $y2 + $ymin;
	my $left  = ($xmax - $xmin) * $x1 + $xmin;
	my $right = ($xmax - $xmin) * $x2 + $xmin;

	my @list;
	if($partial) {
		@list = Tkx::SplitList($canvas->find_overlapping($left, $top, $right, $bot));
	} else {
		@list = Tkx::SplitList($canvas->find_enclosed($left, $top, $right, $bot));
	}
	#print "@list\n";
	return [map { grep { $_ =~ /page_no/ } Tkx::SplitList($canvas->gettags($_)) } @list];
}#}}}
sub draw_page_tag {#{{{
	my $tag = shift;
	$tag =~ /page_no_(\d+)/;
	my $page_no = $1;
	my $photo = Folio::Viewer::Tkx::Imager->get_tk_image(_memo_help($file, $page_no));
	my @coords = Tkx::SplitList($mainWindow{cw_cv}->coords($tag));
	$mainWindow{cw_cv}->create_image($coords[0], $coords[1], -image => $photo, -tags => "photo_no_$page_no", -anchor => 'nw');
}#}}}

sub draw_pages {#{{{
	my ($pages_pdl) = @_;
	my $inter_page_px = 10;
	my $cv_height = sclr(sumover($pages_pdl->xchg(0,1))->slice('1') + ($pages_pdl->dim(1)-1)*$inter_page_px);
	my $max_page_height = max($pages_pdl->slice('1,:'));
	my $max_page_width = max($pages_pdl->slice('0,:'));
	my $cv_width_h = ceil($max_page_width/2.0)->sclr;
	$mainWindow{cw_cv}->configure(-scrollregion => qq/-$cv_width_h 0 $cv_width_h $cv_height/);

	my $top_left_y = 0;
	for my $page (0..$pages_pdl->dim(1)-1) {
		my ($page_width, $page_height) = $pages_pdl->slice(":,$page")->list;
		$mainWindow{cw_cv}->create_rectangle(0-$page_width/2, $top_left_y,
			$page_width/2, $top_left_y+$page_height,
			-fill => 'red',
			-tags => "page page_no_$page");
		$top_left_y += $page_height + 10;
	}
	#$mainWindow{cw}->g_wm_minsize($max_page_width, $max_page_height);
}#}}}
#}}}
# Fetch data {{{
sub fetch_results {#{{{
	my $query_text = $mainWindow{retrieval_search_entry}->get("1.0", "end");
	my $query = $fetcher->query('Google::Scholar', $query_text );
	$results = $query->entries; # GLOBAL
	$current_doc = undef;
	$results = [ # TODO only results which have a sciencedirect link
		grep {
			grep { $_ =~ /sciencedirect/ } @{$_->info->{link}}
		} @$results
	];
	my @list = map {join ' ', @{ $_->info->{title}} } @$results;
	$mainWindow{retrieval_resultsframe_list}->delete(0, 'end');
	$mainWindow{retrieval_resultsframe_list}->insert(0, @list);
	my $show_result_info_cb = sub {
		my $select = $mainWindow{retrieval_resultsframe_list}->curselection;
		if($select >= 0) {
			#use DDP; p $mainWindow{retrieval_resultsinfo_text}->tag_names;
			$current_doc = $results->[$select];
			use DDP; my $str = p($current_doc->info, colored => 1);
			$mainWindow{retrieval_resultsinfo_text}->delete('1.0', 'end');
			Folio::Viewer::Tkx::TextANSI->insert_ANSI_text(
				$mainWindow{retrieval_resultsinfo_text},
				$str);
		}
	};
	my $get_pdf = sub {
		my $select = $mainWindow{retrieval_resultsframe_list}->curselection;
		if($select >= 0) {
			fetch_doc($results->[$select]);
		}
	};
	$mainWindow{retrieval_resultsframe_list}->g_bind("<<ListboxSelect>>", $show_result_info_cb);
	$mainWindow{retrieval_resultsframe_list}->g_bind("<Control-g>", $get_pdf);
	$mainWindow{retrieval_resultsinfo_text}->g_bind("<Control-g>", sub {
		fetch_doc($current_doc) if defined $current_doc;
	});
}#}}}
sub fetch_doc {#{{{
	my ($result) = @_;
	my $links = $result->info->{link};
	my $sd_link = [grep { $_ =~ /sciencedirect/ } @$links]->[0];
	use DDP; p $sd_link;
	#my $pdf_response =
	fetch_progress_dialog(
		['ScienceDirect', $sd_link->as_string],
		(join ' ', @{$result->info->{title}}),
	);
}#}}}
sub fetch_progress_dialog {#{{{
	my ($doc_param, $info) = @_;
	my $cur_req = $request_num++;
	#my $done_var :shared;
	#$done_var = "progress_done$cur_req";
	#Tkx::set("$done_var" => 0);
	my $data = {
		action => 'get_doc',
		doc_id => $cur_req,
		doc_param => $doc_param,
		progress_max => 1000,

	};
	# Widgets{{{
	my $dialog = $mainWindow{retrieval}->new_toplevel;
	$dialog->new_ttk__label(-text => $info)->g_pack(-side => 'top');
	my $progressbar = $dialog->new_ttk__progressbar(-orient => 'horizontal', -maximum => $data->{progress_max},
		-length => 200, -mode => 'determinate');
	$progressbar->g_pack(-side => 'bottom');
	#}}}
	#$request_doc{$cur_req} = $doc;
	$data->{progressbar} = $progressbar;
	my $h = shared_clone($data);
	push @request_todo, $h;

	#Tkx::vwait("$done_var");
	##my $data = $requests_done_thr_data{$done_var};
	#return $data;
}#}}}
sub write_and_open_response {#{{{
	my ($pdf_response) = @_;
	return unless $pdf_response->code == 200;
	my $pdf_filename = $pdf_response->filename;
	my ($name,undef,$suffix) = fileparse($pdf_filename,qw/pdf/);
	my ($fh, $filename) = tempfile( $name . 'XXXX' , SUFFIX => ".$suffix");
	write_file($filename, $pdf_response->decoded_content);
	close $fh;
	open_file($filename);
}#}}}
sub open_file {#{{{
	my ($filename) = @_;

	$file = $filename;
	$doc = $manage->get_document($file);
	print "Pages: @{[$doc->page_count]}\n";

	$mainWindow{page_num} = 0;
	$mainWindow{mw}->g_wm_title($file);
	update_label();

	# TODO : set as just the first page (or in the future, detect title-like page)
	my $first_page_icon = $manage
			->get_document_page_imager($file, 0)
			->scale(xpixels => 200, ypixels => 200, type => 'min');
	my $photo_icon = Folio::Viewer::Tkx::Imager->get_tk_image($first_page_icon);
	$mainWindow{mw}->g_wm_iconphoto($photo_icon);

	$doc_bounds = null;
	for my $page_num (0..$doc->page_count-1) {
		$doc_bounds = $doc_bounds->glue(1,pdl $manage->get_page_bounds($file, $page_num));
	}
	croak("Size mismatch") unless $doc_bounds->dim(1) == $doc->page_count;

	draw_pages($doc_bounds);

	0;
}#}}}
sub request_worker {#{{{
	while($thread_run) {
		while(@request_todo) {
			my $req = shift @request_todo;
			if($req->{action} eq 'get_doc') {
				my %data;
				$data{max} = $req->{progress_max};
				my $fetcher = Fetch::Paper->new();
				my $proxy = Fetch::Paper::Proxy->new( fetch => $fetcher );
				my $doc_param = [$req->{doc_param}->[0], URI->new($req->{doc_param}->[1])];
				use DDP; p $doc_param;
				my $doc = $fetcher->doc(@$doc_param, proxy => $proxy);
				my $response = $doc->get_pdf(':content_cb' => sub {
					my ($chunk, $response, $protocol) = @_;
					$data{bytes} += length $chunk;
					$data{content} .= $chunk;
					if($data{content_length}) {
						$data{progress} = int($data{max}*$data{bytes}/$data{content_length});
						push @response_done, shared_clone({progressbar => $req->{progressbar},
							action => 'update_progress',
							value => $data{progress} });
						$progress_var = $data{progress};
						print $data{progress}, "\n";
					} elsif($response->content_length) {
						$data{content_length} = $response->content_length;
					}
				});
				$response->content($data{content});
				my $h = shared_clone({
					action => 'open_doc',
					response => $response,
					doc_id => $req->{doc_id},
				});
				push @response_done, $h;
			}
		}
		sleep 3;
	}
	$thread_done = 1;
}#}}}
sub request_cleanup {#{{{
	while(@response_done) {
		return unless $request_cleanup_repeat;
		my $resp = shift @response_done;
		if($resp->{action} eq 'update_progress') {
			$resp->{progressbar}->configure(-value => $resp->{value});
			Tkx::update();
		} elsif($resp->{action} eq 'open_doc') {
			write_and_open_response($resp->{response});
			# TODO : do something with $request_doc{$resp->{doc_id}};
		}
	}
}#}}}
#}}}
# Page change {{{
sub page_change {#{{{
	my ($delta) = @_;
	my $target = $mainWindow{page_num} + $delta;
	return 0 if $target < 0 or $target >= $doc->page_count;
	$mainWindow{page_num} = $target;
	return 1;
}#}}}
sub update_label {#{{{
	my $photo = Folio::Viewer::Tkx::Imager->get_tk_image(get_current_page_imager());
	$mainWindow{main_page_image}->configure(-image => $photo);
	my ($height, $width) = (Tkx::image_height $photo, Tkx::image_width $photo);
	$mainWindow{mw}->g_wm_minsize( $width, $height ); 
		# force a size if needed.  Helps with some pack layouts
}#}}}
sub get_current_page_imager {#{{{
	# TODO uses global $file
	_memo_help($file, $mainWindow{page_num});
}#}}}
sub _memo_help {#{{{
	my ($file, $page_num) = @_;
	$manage->get_document_page_imager($file, $page_num);
}#}}}
#}}}

sub init_main {#{{{
	Tkx::ttk__style_theme_use("clam");
	addMainWindow();
	addRetrievalWindow();
	addCanvasWindow();
	# Page turn bindings {{{
	$mainWindow{mw}->g_bind('<Button-5>', [sub {update_label() if page_change(@_)}, 1]);
	$mainWindow{mw}->g_bind('<Button-4>', [sub {update_label() if page_change(@_)}, -1]);
	$mainWindow{mw}->g_bind('<space>', [sub {update_label() if page_change(@_)}, 1]);
	$mainWindow{mw}->g_bind('<b>', [sub {update_label() if page_change(@_)}, -1]);
	$mainWindow{mw}->g_bind('<Next>', [sub {update_label() if page_change(@_)}, 1]);
	$mainWindow{mw}->g_bind('<Prior>', [sub {update_label() if page_change(@_)}, -1]);
	$mainWindow{mw}->g_bind('q', [sub {cleanup(); done(); }]);
	#}}}
	# Canvas scroll bindings {{{
	$mainWindow{cw}->g_bind('<Button-5>', [sub {$mainWindow{cw_cv}->yview( scroll => @_, 'units')}, 1]);
	$mainWindow{cw}->g_bind('<Button-4>', [sub {$mainWindow{cw_cv}->yview( scroll => @_, 'units')}, -1]);
	$mainWindow{cw}->g_bind('<space>', [sub {$mainWindow{cw_cv}->yview( scroll => @_, 'units')}, 1]);
	$mainWindow{cw}->g_bind('<b>', [sub {$mainWindow{cw_cv}->yview( scroll => @_, 'units')}, -1]);
	$mainWindow{cw}->g_bind('<Next>', [sub {$mainWindow{cw_cv}->yview( scroll => @_, 'units')}, 1]);
	$mainWindow{cw}->g_bind('<Prior>', [sub {$mainWindow{cw_cv}->yview( scroll => @_, 'units')}, -1]);
	$mainWindow{cw}->g_bind('q', [sub {cleanup(); done(); }]);
	# }}}

	#$mainWindow{retrieval_search_entry}->g_bind('<KeyPress>', [ sub { print "Moo\n"; }, 1 ] );
	#$mainWindow{retrieval_search_entry}->g_bind('<Shift-Return>', [ sub { print "Eep\n"; Tkx::continue; }, 1 ] );
	$mainWindow{retrieval_search_entry}->g_bind('<Control-g>', [ sub { fetch_results() }, 1 ] );
	#$mainWindow{retrieval_search_entry}->g_bind(q/<Key>/, [sub { print  "You pressed the key called @_\n"; }, Tkx::Ev('%K', '%s') ]);

	# Set up ANSI tags for text {{{
	Folio::Viewer::Tkx::TextANSI->add_ANSI_tags($mainWindow{retrieval_resultsinfo_text});
	$mainWindow{retrieval_resultsinfo_text}->tag_raise('sel');
	#}}}
}#}}}
sub cleanup {#{{{
	$thread_run = 0;
	while(not $thread_done and @response_done) {
		sleep 1;
	}
	$request_cleanup_repeat = 0;
	Tkx::destroy($mainWindow{mw});
}#}}}
sub done {#{{{
	#exit;
}#}}}
sub main {#{{{
	init_main;
	if(@ARGV) {
		open_file(shift @ARGV)
	} else {
		$mainWindow{mw}->g_wm_title("tk pdf");
		$mainWindow{mw}->g_wm_minsize( 300, 400 ); 
	}
	$thread = threads->new(\&request_worker);
	Folio::Viewer::Tkx::Timer::repeat(50, \&request_cleanup, \$request_cleanup_repeat);
	#Tkx::after( idle => sub {
		#repeat(3000, \&file_opener , \$file_open_repeat);
	#} );
	Tkx::MainLoop();
	$thread->join;

	return 0;
}#}}}

main();

# {{{

__END__

Graphviz to canvas
    use DDP; p $mainWindow{cw_cv};
    my $g = Tkx::widget->new( Tkx::dotnew( digraph => rankdir => 'LR' ) );
    use DDP; p $g;
    $g->setnodeattribute(style => qw/filled color white/);
    Tkx::widget->new($g->addnode('Hello'))->addedge(Tkx::widget->new($g->addnode('World!')));
    $g->layout;
    use DDP; $g->render;
    Tkx::eval($g->render($mainWindow{cw_cv}));

# vim: fdm=marker
